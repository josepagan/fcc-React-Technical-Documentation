<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>React Documentation</title>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>

  </head>

  <body>
<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <div class="grid-container">
      <nav id="nav-bar">
        <a class="nav-link" href="What_is_React"><div class="linkblock"><p>What is React</p></div></a>
        <a class="nav-link" href="JSX"><div class="linkblock"><p>JSX</p></div></a>
        <a class="nav-link" href="Components_And_Props"><div class="linkblock"><p>Components And Props</p></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
        <a class="nav-link" href=""><div class="linkblock"></div></a>
      </nav>
      <main id="main-doc grid-item">
        <section id="What_is_React" class="main-section">
          <header>What is React</header>
          <p>React is a JavaScript library for building user interfaces.</p>
          <ul>
            <li>
              Declarative
              <p>React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.</p>
              <p>Declarative views make your code more predictable and easier to debug.</p>
            </li>
            <li>
              Component-Based
              <p>Build encapsulated components that manage their own state, then compose them to make complex UIs.</p>
              <p>Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM.</p>
            </li>
          </ul>
        </section>
        <section id="JSX" class="main-section">
          <header>JSX</header>
          <p>JSX is a sintax extension to JSX, it might remind you of a template language but it has all the power of Javascript.</p>
          <div class="codebox">
          <code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code>
          </div>
          <h2>Why JSX</h2>
          <p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</p>
          <p>Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both.</p>
          <p>React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</p>
          <h2>Embedding Expressions in JSX</h2>
          <p>You can put any valid JavaScript expression inside curly  braces in JSX</p>
          <div class="codebox"><code>function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Harper',
  lastName: 'Perez'
};

const element = (
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);

ReactDOM.render(
  element,
  document.getElementById('root')
);</code></div>
          <h2>JSX is an Expression Too</h2>
          <p>After compilation, JSX expresions become regular JS function calls, and evaluate to JS objects.</p>
          <p>This means that you can use JSX inside if statements, for loops, assing it to variables and return it from functions.</p>
        </section>
        <section id="Rendering_Elements" class="main-section">
          <header>Rendering Elements</header>
          <p> An element describes what you want to see on the screen.</p>
          <p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
           <p>React elements are immutable. Once you create an element, you can't change its children or attributes.</p>
           <h2>React Only Updates Whates Necessary</h2>
           <p>
           React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.
           </p>
        </section>
        <section id="Components_And_Props" class="main-section">
        <p>
          Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.<headConceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.er>Components And Props</header>
        </p>
        <div class="codebox"><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById('root')
  );</code></div>
        <ol>
          <p>In this example:</p>
          <li>We call ReactDOM.render() with the &lt;Welcome name=&quot;Sara&quot; /&gt; element.</li>
          <li>React calls the Welcome component with {name: 'Sara'} as the props.</li>
          <li>Our Welcome component returns a &lt;h1&gt;Hello, Sara&lt;/h1&gt; element as the result.</li>
          <li>React DOM efficiently updates the DOM to match &lt;h1&gt;Hello, Sara&lt;/h1&gt;.          </li>
        </ol>
        <h2>Composing Components</h2>
        <p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
        <h2>Extracting Components</h2>
        <p>Components can be split into smaller components...</p>
        <div class="codebox">
<code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=\&quot;Sara\&quot; /&gt;
      &lt;Welcome name=\&quot;Cahal\&quot; /&gt;
      &lt;Welcome name=\&quot;Edite\&quot; /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(\'root\')
);</code></div>
        <p>Accepts autor, text and date as props and describes a comment on a social media website. It is not very reusable because of the nesting. So it is a good candidate to decompose.</p>
        <p>First we will extract Avatar:</p>
        <div class="codebox">
          <code>
function Avatar(props) {
  return (
    &lt;img className=\&quot;Avatar\&quot;
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;
  );
}
          </code>
        </div>

        <p>We can simplify Comment:</p>
        <div class="codebox">
          <code>
function Comment(props) {
  return (
    &lt;div className=\&quot;Comment\&quot;&gt;
      &lt;div className=\&quot;UserInfo\&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=\&quot;UserInfo-name\&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=\&quot;Comment-text\&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=\&quot;Comment-date\&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
          </code>
        </div>
        <p>Next we will extrat an UserInfo component that renders the Avata next to the users name:</p>
        <div class="codebox">
          <code>
function UserInfo(props) {
  return (
    &lt;div className=\&quot;UserInfo\&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=\&quot;UserInfo-name\&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
} 
          </code></div>
          <p>This lets us simplify Comment even further:</p>
          <div class="codebox">
            <code>
function Comment(props) {
  return (
    &lt;div className=\&quot;Comment\&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=\&quot;Comment-text\&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=\&quot;Comment-date\&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
} 
            </code>
          </div>
          <h2>Props are Read-Only</h2>
          <p>A component must never modify its own props. All react components must act like pure functions with respect to their propsA component must never modify its own props. All react components must act like pure functions with respect to their propsA component must never modify its own props. All react components must act like pure functions with respect to their props.</p>
        </section>
        <section id="state-and-lifecycle" class="main-section">
          <header>State and Lifecycle</header>
          <p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. </p>
          <p>We can declare special methods on the component class to run some code when a component mounts and unmounts. These methods are called “lifecycle methods”.</p>
          <h2>Using State Correctly</h2>
          <ul>
            <li>
              <h3>Do Not Modify State Directly</h3>
              <p>Instead, use setState().
              The only place where you can assign this.state is the constructor.</p>
            </li>
            <li>
              <h3>State Updates May Be Asynchronous</h3>
              <p>React may batch multiple setState() calls into a single update for performace.</p>
              <p>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p>
              <p>To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p>
            </li>
            <li>
              <h3>State Updates are Merged</h3>
            </li>  
            <h2>The Data Flows Down</h2>
            <p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.
This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p>
          </ul>
        </section>
        <section>
          
        </section>
      </main>
    </div>
  </body>
</html>
